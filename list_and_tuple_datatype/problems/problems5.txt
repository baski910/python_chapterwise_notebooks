1. Write a function that pairs the first number in an array with the last, the second number with the second to last, etc.

Examples
pairs([1, 2, 3, 4, 5, 6, 7]) ➞ [[1, 7], [2, 6], [3, 5], [4, 4]]

pairs([1, 2, 3, 4, 5, 6]) ➞ [[1, 6], [2, 5], [3, 4]]

pairs([5, 9, 8, 1, 2]) ➞ [[5, 2], [9, 1], [8, 8]]

pairs([]) ➞ []


2. Write a function that returns True if you can use the letters of the first string to create the second string. Letters are case sensitive.

can_build("aPPleAL", "PAL") ➞ True

can_build("aPPleAL", "apple") ➞ False

can_build("a", "") ➞ True

can_build("aa", "aaa") ➞ False


3. You are given two strings s and t. String t is generated by randomly shuffling string s and then adding one more letter at a random position. Return the letter that was added to t.

Examples
find_the_difference("abcd", "abcde") ➞ "e"

find_the_difference("", "y") ➞ "y"

find_the_difference("ae", "aea") ➞ "a"


4. Create a function that sums up all the elements in the list recursively. The use of the sum() built-in function is not allowed, thus, the approach is recursive.

Examples
recur_add([1, 2, 3, 4, 10, 11]) ➞ 31

recur_add([-3, 4, 11, 10, 21, 32, -9]) ➞ 66

recur_add([-21, -7, 19, 3, 4, -8]) ➞ -10
Notes
You're expected to solve this challenge using a recursive approach.


5. Create a function that returns which chapter is nearest to the page you're on. If two chapters are equidistant, return the chapter with the higher page number.

Examples
nearest_chapter({
  "Chapter 1" : 1,
  "Chapter 2" : 15,
  "Chapter 3" : 37
}, 10) ➞ "Chapter 2"


nearest_chapter({
  "New Beginnings" : 1,
  "Strange Developments" : 62,
  "The End?" : 194,
  "The True Ending" : 460
}, 200) ➞ "The End?"


nearest_chapter({
  "Chapter 1a" : 1,
  "Chapter 1b" : 5
}, 3) ➞ "Chapter 1b"
Notes
All page numbers in the dictionary will be valid integers.


6. Create a function that returns a list containing the prime factors of whatever integer is passed to it.

Examples
prime_factors(20) ➞ [2, 2, 5]

prime_factors(100) ➞ [2, 2, 5, 5]

prime_factors(8912234) ➞ [2, 47, 94811]
Notes
Implement your solution using trial division.
Your solution should not require recursion.


7. Write a function that returns the length of the shortest contiguous sublist whose sum of all elements strictly exceeds n.

Examples
min_length([5, 8, 2, -1, 3, 4], 9) ➞ 2

min_length([3, -1, 4, -2, -7, 2], 4) ➞ 3
# Shortest sublist whose sum exceeds 4 is: [3, -1, 4]

min_length([1, 0, 0, 0, 1], 1) ➞ 5

min_length([0, 1, 1, 0], 2) ➞ -1
Notes
The sublist should be composed of contiguous elements from the original list.
If no such sublist exists, return -1.


8. Create a function that determines whether each seat can "see" the front-stage. A number can "see" the front-stage if it is strictly greater than the number before it.

Everyone can see the front-stage in the example below:

# FRONT STAGE
[[1, 2, 3, 2, 1, 1],
[2, 4, 4, 3, 2, 2],
[5, 5, 5, 5, 4, 4],
[6, 6, 7, 6, 5, 5]]

# Starting from the left, the 6 > 5 > 2 > 1, so all numbers can see.
# 6 > 5 > 4 > 2 - so all numbers can see, etc.
Not everyone can see the front-stage in the example below:

# FRONT STAGE
[[1, 2, 3, 2, 1, 1], 
[2, 4, 4, 3, 2, 2], 
[5, 5, 5, 10, 4, 4], 
[6, 6, 7, 6, 5, 5]]

# The 10 is directly in front of the 6 and blocking its view.
The function should return True if every number can see the front-stage, and False if even a single number cannot.

Examples
can_see_stage([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]) ➞ True

can_see_stage([
  [0, 0, 0],
  [1, 1, 1],
  [2, 2, 2]
]) ➞ True

can_see_stage([
  [2, 0, 0], 
  [1, 1, 1], 
  [2, 2, 2]
]) ➞ False

can_see_stage([
  [1, 0, 0],
  [1, 1, 1],
  [2, 2, 2]
]) ➞ False

# Number must be strictly smaller than 
# the number directly behind it.
Notes
Numbers must be strictly greater than the number in front of it.
All numbers within the lists will be whole numbers greater than or equal to zero.


9. Given a sentence, create a function which shifts the first letter of each word to the next word in the sentence (shifting right).

Examples
shift_sentence("create a function") ➞ "freate c aunction"

shift_sentence("it should shift the sentence") ➞ "st ihould shift she tentence"

shift_sentence("the output is not very legible") ➞ "lhe tutput os iot nery vegible"

shift_sentence("edabit") ➞ "edabit"
Notes
The last word shifts its first letter to the first word in the sentence.
All sentences will be given in lowercase.
Note how single words remain untouched (example #4).


10. It's time to send and receive secret messages.

Create a single function that takes a string or a list and returns a coded or decoded message.

The first letter of the string, or the first element of the list represents the Character Code of that letter. The next elements are the differences between the characters: e.g. A +3 --> C or z -1 --> y.

Examples
dif_ciph("Hello") ➞ [72, 29, 7, 0, 3]
# H = 72, the difference between the H and e is 29 (upper- and lowercase).
# The difference between the two l's is obviously 0.

dif_ciph([ 72, 33, -73, 84, -12, -3, 13, -13, -68 ]) ➞ "Hi there!"

dif_ciph("Sunshine") ➞ [83, 34, -7, 5, -11, 1, 5, -9]
Notes
The input of the function will always be a string or a list with numbers.
